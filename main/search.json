[
  {
    "objectID": "reference/deploy_rsconnect.html",
    "href": "reference/deploy_rsconnect.html",
    "title": "deploy_rsconnect",
    "section": "",
    "text": "deploy_rsconnect(\n    connect_server: ConnectServer,\n    board,\n    pin_name: str,\n    version: str = None,\n    extra_files: typing.List[str] = None,\n    new: bool = False,\n    app_id: int = None,\n    title: str = None,\n    python: str = None,\n    force_generate: bool = False,\n    log_callback: typing.Callable = None,\n    image: str = None,\n)\nDeploy to Posit Connect\n\n\n\nconnect_server : rsconnect.api.RSConnectServer\n\nPosit Connect Server\n\nboard : \n\nPins board\n\npin_name : str\n\nName of pin\n\nversion : str = None\n\nVersion of pin\n\nextra_files : typing.List[str] = None\n\nAny extra files to include\n\nnew : bool = False\n\nForce as a new deploy\n\napp_id : int = None\n\nID of an existing application to deploy new files for.\n\ntitle : str = None\n\nOptional title for the deploy.\n\npython : str = None\n\nOptional name of a Python executable\n\nforce_generate : bool = False\n\nForce generating requirements.txt or environment.yml\n\nlog_callback : typing.Callable = None\n\nCallback to use to write the log to\n\nimage : str = None\n\nDocker image to be specified for off-host execution\n\n\n\n\n\nimport vetiver\nimport pins\nimport rsconnect\n\n# Set up Connect Server and board\nboard = pins.board_connect(allow_pickle_read=True)\nconnect_server = rsconnect.api.RSConnectServer(\n   url = url,\n   api_key = api_key\n)\n\n# Deploy model, which should already be pinned on Posit Connect\nvetiver.deploy_rsconnect(\n    connect_server = connect_server,\n    board = board,\n   pin_name = \"my_model\"\n)",
    "crumbs": [
      "Reference",
      "Deploy",
      "deploy_rsconnect"
    ]
  },
  {
    "objectID": "reference/deploy_rsconnect.html#parameters",
    "href": "reference/deploy_rsconnect.html#parameters",
    "title": "deploy_rsconnect",
    "section": "",
    "text": "connect_server : rsconnect.api.RSConnectServer\n\nPosit Connect Server\n\nboard : \n\nPins board\n\npin_name : str\n\nName of pin\n\nversion : str = None\n\nVersion of pin\n\nextra_files : typing.List[str] = None\n\nAny extra files to include\n\nnew : bool = False\n\nForce as a new deploy\n\napp_id : int = None\n\nID of an existing application to deploy new files for.\n\ntitle : str = None\n\nOptional title for the deploy.\n\npython : str = None\n\nOptional name of a Python executable\n\nforce_generate : bool = False\n\nForce generating requirements.txt or environment.yml\n\nlog_callback : typing.Callable = None\n\nCallback to use to write the log to\n\nimage : str = None\n\nDocker image to be specified for off-host execution",
    "crumbs": [
      "Reference",
      "Deploy",
      "deploy_rsconnect"
    ]
  },
  {
    "objectID": "reference/deploy_rsconnect.html#examples",
    "href": "reference/deploy_rsconnect.html#examples",
    "title": "deploy_rsconnect",
    "section": "",
    "text": "import vetiver\nimport pins\nimport rsconnect\n\n# Set up Connect Server and board\nboard = pins.board_connect(allow_pickle_read=True)\nconnect_server = rsconnect.api.RSConnectServer(\n   url = url,\n   api_key = api_key\n)\n\n# Deploy model, which should already be pinned on Posit Connect\nvetiver.deploy_rsconnect(\n    connect_server = connect_server,\n    board = board,\n   pin_name = \"my_model\"\n)",
    "crumbs": [
      "Reference",
      "Deploy",
      "deploy_rsconnect"
    ]
  },
  {
    "objectID": "reference/vetiver_pin_write.html",
    "href": "reference/vetiver_pin_write.html",
    "title": "vetiver_pin_write",
    "section": "",
    "text": "vetiver_pin_write(board, model: VetiverModel, versioned: bool = True)\nPin a trained VetiverModel along with other model metadata.",
    "crumbs": [
      "Reference",
      "Version",
      "vetiver_pin_write"
    ]
  },
  {
    "objectID": "reference/vetiver_pin_write.html#parameters",
    "href": "reference/vetiver_pin_write.html#parameters",
    "title": "vetiver_pin_write",
    "section": "Parameters",
    "text": "Parameters\n\nboard : \n\nA pin board, created by pins.board_folder() or another board_ function.\n\nmodel : VetiverModel\n\nVetiverModel to be written to board\n\nversioned : bool = True\n\nWhether or not the pin should be versioned",
    "crumbs": [
      "Reference",
      "Version",
      "vetiver_pin_write"
    ]
  },
  {
    "objectID": "reference/vetiver_pin_write.html#examples",
    "href": "reference/vetiver_pin_write.html#examples",
    "title": "vetiver_pin_write",
    "section": "Examples",
    "text": "Examples\n\nimport vetiver\nfrom pins import board_temp\nmodel_board = board_temp(versioned = True, allow_pickle_read = True)\nX, y = vetiver.get_mock_data()\nmodel = vetiver.get_mock_model().fit(X, y)\nv = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\nvetiver.vetiver_pin_write(model_board, v)\n\nModel Cards provide a framework for transparent, responsible reporting. \n Use the vetiver `.qmd` Quarto template as a place to start, \n with vetiver.model_card()\nWriting pin:\nName: 'my_model'\nVersion: 20241210T193601Z-eaec0",
    "crumbs": [
      "Reference",
      "Version",
      "vetiver_pin_write"
    ]
  },
  {
    "objectID": "reference/BaseHandler.html",
    "href": "reference/BaseHandler.html",
    "title": "BaseHandler",
    "section": "",
    "text": "BaseHandler(self, model, prototype_data)\nBase handler class for creating VetiverModel of different types of model.\nHandlers are used in Vetiver to as a unified interface for different types of models. They are used to generate predictions and create metadata about a trained model.\n\n\n\nmodel : \n\na trained model\n\nprototype_data : \n\nAn object with information (data) whose layout is to be determined.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconstruct_prototype\nCreate data prototype for a model\n\n\ncreate_meta\nCreate metadata for a model\n\n\ndescribe\nCreate description for model\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\nhandler_startup\nInclude required packages for prediction\n\n\n\n\n\nBaseHandler.construct_prototype()\nCreate data prototype for a model\n\n\n\nprototype_data : pd.DataFrame, np.ndarray, or None\n\nTraining data to create prototype\n\n\n\n\n\n\nprototype : pd.DataFrame or None\n\nZero-row DataFrame for storing data types\n\n\n\n\n\n\nBaseHandler.create_meta(metadata)\nCreate metadata for a model\n\n\n\nBaseHandler.describe()\nCreate description for model\n\n\n\nBaseHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nData used to generate prediction\n\ncheck_prototype : \n\nIf type should be checked against prototype or not\n\n\n\n\n\n\n : prediction\n\nPrediction from model\n\n\n\n\n\n\nBaseHandler.handler_startup()\nInclude required packages for prediction\nThe handler_startup function executes when the API starts. Use this function for tasks like loading packages.",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "BaseHandler"
    ]
  },
  {
    "objectID": "reference/BaseHandler.html#parameters",
    "href": "reference/BaseHandler.html#parameters",
    "title": "BaseHandler",
    "section": "",
    "text": "model : \n\na trained model\n\nprototype_data : \n\nAn object with information (data) whose layout is to be determined.",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "BaseHandler"
    ]
  },
  {
    "objectID": "reference/BaseHandler.html#methods",
    "href": "reference/BaseHandler.html#methods",
    "title": "BaseHandler",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconstruct_prototype\nCreate data prototype for a model\n\n\ncreate_meta\nCreate metadata for a model\n\n\ndescribe\nCreate description for model\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\nhandler_startup\nInclude required packages for prediction\n\n\n\n\n\nBaseHandler.construct_prototype()\nCreate data prototype for a model\n\n\n\nprototype_data : pd.DataFrame, np.ndarray, or None\n\nTraining data to create prototype\n\n\n\n\n\n\nprototype : pd.DataFrame or None\n\nZero-row DataFrame for storing data types\n\n\n\n\n\n\nBaseHandler.create_meta(metadata)\nCreate metadata for a model\n\n\n\nBaseHandler.describe()\nCreate description for model\n\n\n\nBaseHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nData used to generate prediction\n\ncheck_prototype : \n\nIf type should be checked against prototype or not\n\n\n\n\n\n\n : prediction\n\nPrediction from model\n\n\n\n\n\n\nBaseHandler.handler_startup()\nInclude required packages for prediction\nThe handler_startup function executes when the API starts. Use this function for tasks like loading packages.",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "BaseHandler"
    ]
  },
  {
    "objectID": "reference/SKLearnHandler.html",
    "href": "reference/SKLearnHandler.html",
    "title": "SKLearnHandler",
    "section": "",
    "text": "SKLearnHandler(self, model, prototype_data)\nHandler class for creating VetiverModels with sklearn.\n\n\n\nmodel : sklearn.base.BaseEstimator\n\na trained sklearn model\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nSKLearnHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data\n\n\n\n\n\n\nprediction : \n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "SKLearnHandler"
    ]
  },
  {
    "objectID": "reference/SKLearnHandler.html#parameters",
    "href": "reference/SKLearnHandler.html#parameters",
    "title": "SKLearnHandler",
    "section": "",
    "text": "model : sklearn.base.BaseEstimator\n\na trained sklearn model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "SKLearnHandler"
    ]
  },
  {
    "objectID": "reference/SKLearnHandler.html#methods",
    "href": "reference/SKLearnHandler.html#methods",
    "title": "SKLearnHandler",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nSKLearnHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data\n\n\n\n\n\n\nprediction : \n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "SKLearnHandler"
    ]
  },
  {
    "objectID": "reference/StatsmodelsHandler.html",
    "href": "reference/StatsmodelsHandler.html",
    "title": "StatsmodelsHandler",
    "section": "",
    "text": "StatsmodelsHandler(self, model, prototype_data)\nHandler class for creating VetiverModels with statsmodels.\n\n\n\nmodel : statsmodels\n\na trained and fit statsmodels model\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nStatsmodelsHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data\n\n\n\n\n\n\n : prediction\n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "StatsmodelsHandler"
    ]
  },
  {
    "objectID": "reference/StatsmodelsHandler.html#parameters",
    "href": "reference/StatsmodelsHandler.html#parameters",
    "title": "StatsmodelsHandler",
    "section": "",
    "text": "model : statsmodels\n\na trained and fit statsmodels model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "StatsmodelsHandler"
    ]
  },
  {
    "objectID": "reference/StatsmodelsHandler.html#methods",
    "href": "reference/StatsmodelsHandler.html#methods",
    "title": "StatsmodelsHandler",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nStatsmodelsHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data\n\n\n\n\n\n\n : prediction\n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "StatsmodelsHandler"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.run.html",
    "href": "reference/VetiverAPI.run.html",
    "title": "VetiverAPI.run",
    "section": "",
    "text": "VetiverAPI.run(port: int = 8000, host: str = '127.0.0.1', quiet_open, **kw)\nStart API\n\n\n\nport : int = 8000\n\nAn integer that indicates the server port that should be listened on.\n\nhost : str = '127.0.0.1'\n\nA valid IPv4 or IPv6 address, which the application will listen on.\n\nquiet_open : bool = False\n\nIf host is a localhost address, try to automatically open API in browser\n\n\n\n\n\nfrom vetiver import mock, VetiverModel, VetiverAPI\nX, y = mock.get_mock_data()\nmodel = mock.get_mock_model().fit(X, y)\n\nv = VetiverModel(model = model, model_name = \"my_model\", prototype_data = X)\nv_api = VetiverAPI(model = v, check_prototype = True)\nv_api.run()",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI.run"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.run.html#parameters",
    "href": "reference/VetiverAPI.run.html#parameters",
    "title": "VetiverAPI.run",
    "section": "",
    "text": "port : int = 8000\n\nAn integer that indicates the server port that should be listened on.\n\nhost : str = '127.0.0.1'\n\nA valid IPv4 or IPv6 address, which the application will listen on.\n\nquiet_open : bool = False\n\nIf host is a localhost address, try to automatically open API in browser",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI.run"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.run.html#examples",
    "href": "reference/VetiverAPI.run.html#examples",
    "title": "VetiverAPI.run",
    "section": "",
    "text": "from vetiver import mock, VetiverModel, VetiverAPI\nX, y = mock.get_mock_data()\nmodel = mock.get_mock_model().fit(X, y)\n\nv = VetiverModel(model = model, model_name = \"my_model\", prototype_data = X)\nv_api = VetiverAPI(model = v, check_prototype = True)\nv_api.run()",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI.run"
    ]
  },
  {
    "objectID": "reference/SpacyHandler.html",
    "href": "reference/SpacyHandler.html",
    "title": "SpacyHandler",
    "section": "",
    "text": "SpacyHandler(self, model, prototype_data)\nHandler class for creating VetiverModels with spacy.\n\n\n\nmodel : \n\na trained and fit spacy model\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconstruct_prototype\nCreate data prototype for a spacy model, which is one column of string data\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nSpacyHandler.construct_prototype()\nCreate data prototype for a spacy model, which is one column of string data\n\n\n\nprototype : \n\nInput data prototype for spacy model\n\n\n\n\n\n\nSpacyHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data. The SpacyHandler expects an input of a 1 column DataFrame with the same column names as the prototype data, or column name “text” if no prototype was given.\n\n\n\n\n\n\n : prediction\n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "SpacyHandler"
    ]
  },
  {
    "objectID": "reference/SpacyHandler.html#parameters",
    "href": "reference/SpacyHandler.html#parameters",
    "title": "SpacyHandler",
    "section": "",
    "text": "model : \n\na trained and fit spacy model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "SpacyHandler"
    ]
  },
  {
    "objectID": "reference/SpacyHandler.html#methods",
    "href": "reference/SpacyHandler.html#methods",
    "title": "SpacyHandler",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconstruct_prototype\nCreate data prototype for a spacy model, which is one column of string data\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nSpacyHandler.construct_prototype()\nCreate data prototype for a spacy model, which is one column of string data\n\n\n\nprototype : \n\nInput data prototype for spacy model\n\n\n\n\n\n\nSpacyHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data. The SpacyHandler expects an input of a 1 column DataFrame with the same column names as the prototype data, or column name “text” if no prototype was given.\n\n\n\n\n\n\n : prediction\n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "SpacyHandler"
    ]
  },
  {
    "objectID": "reference/vetiver_create_prototype.html",
    "href": "reference/vetiver_create_prototype.html",
    "title": "vetiver_create_prototype",
    "section": "",
    "text": "vetiver_create_prototype(data)\nCreate zero row structure to save data types\n\n\n\ndata : object\n\nAn object with information (data) whose layout is to be determined.\n\n\n\n\n\n\nprototype : vetiver.Prototype\n\nData prototype",
    "crumbs": [
      "Reference",
      "Version",
      "vetiver_create_prototype"
    ]
  },
  {
    "objectID": "reference/vetiver_create_prototype.html#parameters",
    "href": "reference/vetiver_create_prototype.html#parameters",
    "title": "vetiver_create_prototype",
    "section": "",
    "text": "data : object\n\nAn object with information (data) whose layout is to be determined.",
    "crumbs": [
      "Reference",
      "Version",
      "vetiver_create_prototype"
    ]
  },
  {
    "objectID": "reference/vetiver_create_prototype.html#returns",
    "href": "reference/vetiver_create_prototype.html#returns",
    "title": "vetiver_create_prototype",
    "section": "",
    "text": "prototype : vetiver.Prototype\n\nData prototype",
    "crumbs": [
      "Reference",
      "Version",
      "vetiver_create_prototype"
    ]
  },
  {
    "objectID": "reference/write_docker.write_docker.html",
    "href": "reference/write_docker.write_docker.html",
    "title": "write_docker.write_docker",
    "section": "",
    "text": "write_docker.write_docker(\n    app_file: str = 'app.py',\n    path: str = './',\n    rspm_env: bool = False,\n    host: str = '0.0.0.0',\n    port: str = '8080',\n)\nWrites a Dockerfile to run VetiverAPI in a container",
    "crumbs": [
      "Reference",
      "Deploy",
      "write_docker.write_docker"
    ]
  },
  {
    "objectID": "reference/write_docker.write_docker.html#parameters",
    "href": "reference/write_docker.write_docker.html#parameters",
    "title": "write_docker.write_docker",
    "section": "Parameters",
    "text": "Parameters\n\napp_file : str = 'app.py'\n\nFile containing VetiverAPI to be deployed into container\n\npath : str = './'\n\nPath to save Dockerfile\n\nrspm_env : bool = False\n\nWhether or not Posit Package Manager should be used\n\nhost : str = '0.0.0.0'\n\nHost address to run VetiverAPI from Dockerfile\n\nport : str = '8080'\n\nPort to run VetiverAPI from Dockerfile",
    "crumbs": [
      "Reference",
      "Deploy",
      "write_docker.write_docker"
    ]
  },
  {
    "objectID": "reference/write_docker.write_docker.html#examples",
    "href": "reference/write_docker.write_docker.html#examples",
    "title": "write_docker.write_docker",
    "section": "Examples",
    "text": "Examples\n\nimport vetiver\nimport tempfile\nimport pins\ntmp = tempfile.TemporaryDirectory()\nboard = pins.board_temp(allow_pickle_read=True)\n\nX, y = vetiver.get_mock_data()\nmodel = vetiver.get_mock_model().fit(X, y)\nv = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\n\nvetiver.vetiver_pin_write(board, v)\nvetiver.write_app(board,\n    \"my_model\",\n    file = tmp.name + \"/app.py\")\nvetiver.write_docker(app_file = \"app.py\", path = tmp.name)\n\nModel Cards provide a framework for transparent, responsible reporting. \n Use the vetiver `.qmd` Quarto template as a place to start, \n with vetiver.model_card()\nWriting pin:\nName: 'my_model'\nVersion: 20241210T193542Z-d1862",
    "crumbs": [
      "Reference",
      "Deploy",
      "write_docker.write_docker"
    ]
  },
  {
    "objectID": "reference/templates.model_card.html",
    "href": "reference/templates.model_card.html",
    "title": "templates.model_card",
    "section": "",
    "text": "templates.model_card(path)\nCreate a model card for documentation\nThis model card template is generated as a Quarto document. Visit the Quarto website for more info.",
    "crumbs": [
      "Reference",
      "Version",
      "templates.model_card"
    ]
  },
  {
    "objectID": "reference/templates.model_card.html#parameters",
    "href": "reference/templates.model_card.html#parameters",
    "title": "templates.model_card",
    "section": "Parameters",
    "text": "Parameters\n\npath : str = '.'\n\nPath to save model card",
    "crumbs": [
      "Reference",
      "Version",
      "templates.model_card"
    ]
  },
  {
    "objectID": "reference/templates.model_card.html#examples",
    "href": "reference/templates.model_card.html#examples",
    "title": "templates.model_card",
    "section": "Examples",
    "text": "Examples\n\nimport vetiver\nvetiver.model_card()\n\n'./model_card.qmd'",
    "crumbs": [
      "Reference",
      "Version",
      "templates.model_card"
    ]
  },
  {
    "objectID": "reference/templates.monitoring_dashboard.html",
    "href": "reference/templates.monitoring_dashboard.html",
    "title": "templates.monitoring_dashboard",
    "section": "",
    "text": "templates.monitoring_dashboard(path: str = '.')\nGenerate a monitoring dashboard template\nThis template is generated as a Quarto document. Visit the Quarto website for more info.",
    "crumbs": [
      "Reference",
      "Monitor",
      "templates.monitoring_dashboard"
    ]
  },
  {
    "objectID": "reference/templates.monitoring_dashboard.html#parameters",
    "href": "reference/templates.monitoring_dashboard.html#parameters",
    "title": "templates.monitoring_dashboard",
    "section": "Parameters",
    "text": "Parameters\n\npath : str = '.'\n\nPath to save monitoring dashboard",
    "crumbs": [
      "Reference",
      "Monitor",
      "templates.monitoring_dashboard"
    ]
  },
  {
    "objectID": "reference/templates.monitoring_dashboard.html#examples",
    "href": "reference/templates.monitoring_dashboard.html#examples",
    "title": "templates.monitoring_dashboard",
    "section": "Examples",
    "text": "Examples\n\nimport vetiver\nvetiver.monitoring_dashboard()\n\n'./monitoring_dashboard.qmd'",
    "crumbs": [
      "Reference",
      "Monitor",
      "templates.monitoring_dashboard"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.html",
    "href": "reference/VetiverAPI.html",
    "title": "VetiverAPI",
    "section": "",
    "text": "VetiverAPI(\n    self,\n    model: VetiverModel,\n    show_prototype: bool = True,\n    check_prototype: bool = True,\n    app_factory,\n    **kwargs,\n)\nCreate model aware API",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.html#parameters",
    "href": "reference/VetiverAPI.html#parameters",
    "title": "VetiverAPI",
    "section": "Parameters",
    "text": "Parameters\n\nmodel : VetiverModel\n\nModel to be deployed in API\n\nshow_prototype : bool = True\n\nWhether or not to show the data prototype in the API\n\ncheck_prototype : bool = True\n\nDetermine if data prototype should be enforced\n\napp_factory :  = FastAPI\n\nType of API to be deployed\n\n****kwargs** :  = {}\n\nDeprecated parameters.",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.html#examples",
    "href": "reference/VetiverAPI.html#examples",
    "title": "VetiverAPI",
    "section": "Examples",
    "text": "Examples\n\nfrom vetiver import mock, VetiverModel, VetiverAPI\nX, y = mock.get_mock_data()\nmodel = mock.get_mock_model().fit(X, y)\n\nv = VetiverModel(model = model, model_name = \"my_model\", prototype_data = X)\napi = VetiverAPI(model = v, check_prototype = True)",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.html#notes",
    "href": "reference/VetiverAPI.html#notes",
    "title": "VetiverAPI",
    "section": "Notes",
    "text": "Notes\nThis generates an API with 2-4 GET endpoints and 1 POST endpoint.\n├──/ping (GET)\n├──/metadata (GET)\n├──/prototype (GET, if `show_prototype` is True)\n├──/pin-url (GET, if VetiverModel metadata `url` field is not None)\n└──/predict (POST)\nParameter check_ptype was changed to check_prototype. Handling of check_ptype will be removed in a future version.",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.html#methods",
    "href": "reference/VetiverAPI.html#methods",
    "title": "VetiverAPI",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nrun\nStart API\n\n\nvetiver_post\nCreate new POST endpoint that is aware of model input data",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "vetiver ",
    "section": "",
    "text": "Vetiver, the oil of tranquility, is used as a stabilizing ingredient in perfumery to preserve more volatile fragrances.\nThe goal of vetiver is to provide fluent tooling to version, share, deploy, and monitor a trained model. Functions handle both recording and checking the model’s input data prototype, and predicting from a remote API endpoint. The vetiver package is extensible, with generics that can support many kinds of models, and available for both Python and R. To learn more about vetiver, see:\n\nthe documentation at https://vetiver.rstudio.com/\nthe R package at https://rstudio.github.io/vetiver-r/\n\nYou can use vetiver with:\n\nscikit-learn\ntorch\nstatsmodels\nxgboost\nspacy\nor utilize custom handlers to support your own models!\n\n\n\nYou can install the released version of vetiver from PyPI:\npython -m pip install vetiver\nAnd the development version from GitHub with:\npython -m pip install git+https://github.com/rstudio/vetiver-python\n\n\n\nA VetiverModel() object collects the information needed to store, version, and deploy a trained model.\nfrom vetiver import mock, VetiverModel\n\nX, y = mock.get_mock_data()\nmodel = mock.get_mock_model().fit(X, y)\n\nv = VetiverModel(model, model_name='mock_model', prototype_data=X)\nYou can version and share your VetiverModel() by choosing a pins “board” for it, including a local folder, Connect, Amazon S3, and more.\nfrom pins import board_temp\nfrom vetiver import vetiver_pin_write\n\nmodel_board = board_temp(versioned = True, allow_pickle_read = True)\nvetiver_pin_write(model_board, v)\nYou can deploy your pinned VetiverModel() using VetiverAPI(), an extension of FastAPI.\nfrom vetiver import VetiverAPI\napp = VetiverAPI(v, check_prototype = True)\nTo start a server using this object, use app.run(port = 8080) or your port of choice.\n\n\n\nThis project is released with a Contributor Code of Conduct. By contributing to this project, you agree to abide by its terms.\n\nFor questions and discussions about deploying models, statistical modeling, and machine learning, please post on Posit Community.\nIf you think you have encountered a bug, please submit an issue."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "vetiver ",
    "section": "",
    "text": "You can install the released version of vetiver from PyPI:\npython -m pip install vetiver\nAnd the development version from GitHub with:\npython -m pip install git+https://github.com/rstudio/vetiver-python"
  },
  {
    "objectID": "index.html#example",
    "href": "index.html#example",
    "title": "vetiver ",
    "section": "",
    "text": "A VetiverModel() object collects the information needed to store, version, and deploy a trained model.\nfrom vetiver import mock, VetiverModel\n\nX, y = mock.get_mock_data()\nmodel = mock.get_mock_model().fit(X, y)\n\nv = VetiverModel(model, model_name='mock_model', prototype_data=X)\nYou can version and share your VetiverModel() by choosing a pins “board” for it, including a local folder, Connect, Amazon S3, and more.\nfrom pins import board_temp\nfrom vetiver import vetiver_pin_write\n\nmodel_board = board_temp(versioned = True, allow_pickle_read = True)\nvetiver_pin_write(model_board, v)\nYou can deploy your pinned VetiverModel() using VetiverAPI(), an extension of FastAPI.\nfrom vetiver import VetiverAPI\napp = VetiverAPI(v, check_prototype = True)\nTo start a server using this object, use app.run(port = 8080) or your port of choice."
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "vetiver ",
    "section": "",
    "text": "This project is released with a Contributor Code of Conduct. By contributing to this project, you agree to abide by its terms.\n\nFor questions and discussions about deploying models, statistical modeling, and machine learning, please post on Posit Community.\nIf you think you have encountered a bug, please submit an issue."
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Release notes",
    "section": "",
    "text": "For full details, view the commit logs.\n\n\n\n\n\nFull Changelog\n\nMAINT: refactor tests in GH209\nDOCS: Update link to custom handlers documentation in GH208\nENH: add Field examples to model prototypes in GH210\n\n\n\n\n\n\n\nFull Changelog\n\nMAINT: drop Python 3.7 support in GH199\nMAINT: Conda mode deprecated from rsconnect-python pkg in GH197\nMAINT: bump minimum rsconnect to 1.11.0 in GH200\nBUG: remove trailing backslash in GH201\nDOCS: deploying custom elements in GH195\nFEAT: quarto monitoring dashboard template in GH203\nBUG: ignore more in pyright in GH204\nENH: load dotenv file into generated app.py file in GH205\n\n\n\n\n\n\n\nFull Changelog\n\nENH: add root_path if user in Posit Workbench in GH191\n\n\n\n\n\n\nFull Changelog\n\nDOCS: add square logo in GH173\nDOCS: add API structure documentation in GH176\nDOCS: update docs to look less like vetiver.rstudio.com in GH178\nBUG: remove all in init in GH182\nMAINT: require no less than pins 0.7.1 in GH183\nENH: endpoint_fx docstring as FastAPI description in GH179\nMAINT: Update Pydantic usage for v2 compatibility in GH185\nMAINT: Update model_card.qmd by in GH186\nENH: add /GET prototype endpoint in GH174\nBUG: use max instead of first in GH189\n\n\n\n\n\n\n\nFull Changelog\n\nDOC: add changelog in GH151\nFIX: None type handling for python_version in metadata GH149vetiver-python/pull/149\nMatch GHA Python versions to Connect GH157\nDOCS: move from sphinx to quartodoc GH153\nBUG,CI: /latest not rendering correctly GH158\nMAINT: spring cleaning GH160\nDOCS: Add netlify docs preview GH163\nMAINT: spring cleaning GH164\nENH: Refactor server handling GH155\nFEAT: add required packages to authorize pins boards GH166pull/166\nMAINT: start typing vetiver GH168\nFEAT: add new /metadata GET endpoint GH170\nFEAT: implement spacy models GH143\n\n\n\n\n\n\n\nFull Changelog\n\nDOC: Added missing model_name to VetiverModel in GH128\nBUG, MAINT: Catch non 200 codes in GH129\nDOC: fix deploy_rsconnect example in GH1234\nENH: Make vetiver_post extensible for all endpoints in GH130\nTEST: ci testing to run generated dockerfile in GH136\nMAINT: rsconnect-python&gt;=1.8.0 in GH132\nENH: New prepare_docker function in GH137\nDOC: refresh README and add to docs in GH141\nTEST: Update weekly tests: only run necessary tests in GH142\nMAINT: update ptype_data to prototype_data in GH138\nENH: Refactor metadata in GH126\nMAINT: remove stars for explicit imports in GH145\nDOC: Changing language from “Example” to “Examples” for docstrings in GH146\nENH: Added Python version to vetiver_pin_write in GH127\n\n\n\n\n\n\n\nFull Changelog\n\nTEST: pins&lt;&gt;vetiver compatibility test in GH113\nTEST: Update weekly tests to include rsconnect-python in GH117\nDOC: Missing whitespace in InvalidModelError in GH120\nMAINT: Remove xfail from test_rsconnect in GH119\nMAINT: Add httpx in GH125\nENH: Add pin URL to REST API and metadata in GH123\n\n\n\n\n\n\n\nFull Changelog\n\nENH, DOC: have stable and latest docs in GH93\nBUG: bug fix for load_pkgs function on Windows OS in GH98\nMAINT: Update attach_pkgs.py in GH99\nENH: implement statsmodels handler in GH100\nFEAT: xgboost handler in GH101\nENH: adding model card template in GH106\nBUG: refactor pseudo version to pin_url in model card in GH107\nDOC: adding docs, small refactoring in GH108\nENH, DOC: add examples to docstrings in GH109\n\n\n\n\n\n\n\nFull Changelog\n\nENH: add rsconnect_deploy support for board_folder in GH77\nENH: model monitoring in GH76\nDOC: add mini chicago dataset in GH81\nMAINT: remove trailing slashes in API paths GH\nENH: explicitly add n to hover data in plot_metrics in GH84\nENH: initial vetiver_pin_metrics implementation in GH82\nMAINT, ENH: Use setuptools_scm for tagged versioning in GH86\nENH: handlers to register themselves in GH87\nBUG: coerce date var to datetime in GH89"
  },
  {
    "objectID": "changelog.html#whats-changed",
    "href": "changelog.html#whats-changed",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nMAINT: refactor tests in GH209\nDOCS: Update link to custom handlers documentation in GH208\nENH: add Field examples to model prototypes in GH210"
  },
  {
    "objectID": "changelog.html#whats-changed-1",
    "href": "changelog.html#whats-changed-1",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nMAINT: drop Python 3.7 support in GH199\nMAINT: Conda mode deprecated from rsconnect-python pkg in GH197\nMAINT: bump minimum rsconnect to 1.11.0 in GH200\nBUG: remove trailing backslash in GH201\nDOCS: deploying custom elements in GH195\nFEAT: quarto monitoring dashboard template in GH203\nBUG: ignore more in pyright in GH204\nENH: load dotenv file into generated app.py file in GH205"
  },
  {
    "objectID": "changelog.html#whats-changed-2",
    "href": "changelog.html#whats-changed-2",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nENH: add root_path if user in Posit Workbench in GH191"
  },
  {
    "objectID": "changelog.html#v0.2.2",
    "href": "changelog.html#v0.2.2",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nDOCS: add square logo in GH173\nDOCS: add API structure documentation in GH176\nDOCS: update docs to look less like vetiver.rstudio.com in GH178\nBUG: remove all in init in GH182\nMAINT: require no less than pins 0.7.1 in GH183\nENH: endpoint_fx docstring as FastAPI description in GH179\nMAINT: Update Pydantic usage for v2 compatibility in GH185\nMAINT: Update model_card.qmd by in GH186\nENH: add /GET prototype endpoint in GH174\nBUG: use max instead of first in GH189"
  },
  {
    "objectID": "changelog.html#v0.2.1",
    "href": "changelog.html#v0.2.1",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nDOC: add changelog in GH151\nFIX: None type handling for python_version in metadata GH149vetiver-python/pull/149\nMatch GHA Python versions to Connect GH157\nDOCS: move from sphinx to quartodoc GH153\nBUG,CI: /latest not rendering correctly GH158\nMAINT: spring cleaning GH160\nDOCS: Add netlify docs preview GH163\nMAINT: spring cleaning GH164\nENH: Refactor server handling GH155\nFEAT: add required packages to authorize pins boards GH166pull/166\nMAINT: start typing vetiver GH168\nFEAT: add new /metadata GET endpoint GH170\nFEAT: implement spacy models GH143"
  },
  {
    "objectID": "changelog.html#v0.2.0",
    "href": "changelog.html#v0.2.0",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nDOC: Added missing model_name to VetiverModel in GH128\nBUG, MAINT: Catch non 200 codes in GH129\nDOC: fix deploy_rsconnect example in GH1234\nENH: Make vetiver_post extensible for all endpoints in GH130\nTEST: ci testing to run generated dockerfile in GH136\nMAINT: rsconnect-python&gt;=1.8.0 in GH132\nENH: New prepare_docker function in GH137\nDOC: refresh README and add to docs in GH141\nTEST: Update weekly tests: only run necessary tests in GH142\nMAINT: update ptype_data to prototype_data in GH138\nENH: Refactor metadata in GH126\nMAINT: remove stars for explicit imports in GH145\nDOC: Changing language from “Example” to “Examples” for docstrings in GH146\nENH: Added Python version to vetiver_pin_write in GH127"
  },
  {
    "objectID": "changelog.html#v0.1.8",
    "href": "changelog.html#v0.1.8",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nTEST: pins&lt;&gt;vetiver compatibility test in GH113\nTEST: Update weekly tests to include rsconnect-python in GH117\nDOC: Missing whitespace in InvalidModelError in GH120\nMAINT: Remove xfail from test_rsconnect in GH119\nMAINT: Add httpx in GH125\nENH: Add pin URL to REST API and metadata in GH123"
  },
  {
    "objectID": "changelog.html#v0.1.7",
    "href": "changelog.html#v0.1.7",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nENH, DOC: have stable and latest docs in GH93\nBUG: bug fix for load_pkgs function on Windows OS in GH98\nMAINT: Update attach_pkgs.py in GH99\nENH: implement statsmodels handler in GH100\nFEAT: xgboost handler in GH101\nENH: adding model card template in GH106\nBUG: refactor pseudo version to pin_url in model card in GH107\nDOC: adding docs, small refactoring in GH108\nENH, DOC: add examples to docstrings in GH109"
  },
  {
    "objectID": "changelog.html#v0.1.6",
    "href": "changelog.html#v0.1.6",
    "title": "Release notes",
    "section": "",
    "text": "Full Changelog\n\nENH: add rsconnect_deploy support for board_folder in GH77\nENH: model monitoring in GH76\nDOC: add mini chicago dataset in GH81\nMAINT: remove trailing slashes in API paths GH\nENH: explicitly add n to hover data in plot_metrics in GH84\nENH: initial vetiver_pin_metrics implementation in GH82\nMAINT, ENH: Use setuptools_scm for tagged versioning in GH86\nENH: handlers to register themselves in GH87\nBUG: coerce date var to datetime in GH89"
  },
  {
    "objectID": "custom_code.html",
    "href": "custom_code.html",
    "title": "Creating and deploying custom code",
    "section": "",
    "text": "Creating and deploying custom code\nIn some cases, you may need to create and deploy custom code as part of your MLOps workflow using vetiver. This could be necessary when you need to:\n\ndeploy custom models in vetiver\ndeploy unsupported models in vetiver\ninclude custom code in vetiver\ndeploy a vetiver model with a custom pipeline\n\nYou may also have custom code in a known framework, such as a column transformer for a scikit-learn model.\nIn these cases, extra steps will be required to successfully create and deploy a VetiverModel object.\n\n\nMaking a custom model\nVetiver supports basic scikit-learn, torch, statsmodels, xgboost, and spacy models. If you need to alter the usage of these models, or deploy a different type of model, you will likely need to create a new model handler.\nTo create a model handler, you should create a subclass of vetiver’s BaseHandler class. This handler should include the following:\n\nmodel_type: A static method that declares the type of your model.\nhandler_predict(): A method that defines how predictions should be made for your model. This method is used at the /predict endpoint in the VetiverAPI.\n\nHere’s an example of a handler for a model of newmodeltype type. Once you have defined your handler, you can initialize it with your model and pass it to the VetiverModel class.\nfrom vetiver.handlers.base import BaseHandler\n\nclass CustomHandler(BaseHandler):\n    def __init__(self, model, prototype_data):\n        super().__init__(model, prototype_data)\n\n    model_type = staticmethod(lambda: newmodeltype)\n    pip_name = \"scikit-learn\" # package's installation name on pip\n\n    def handler_predict(self, input_data, check_prototype: bool):\n        \"\"\"\n        Your code for making predictions using the custom model\n\n        Parameters\n        ----------\n        input_data:\n            Data POSTed to API endpoint\n        check_prototype: bool\n            Whether the prototype should be enforced\n        \"\"\"\n        prediction = model.fancy_new_predict(input_data)\n\n        return prediction\n\nnew_model = CustomHandler(model, prototype_data)\n\nVetiverModel(new_model, \"custom_model\")\nIf your model is a common type, please consider submitting a pull request.\nTo deploy custom code, you need to include the necessary source code in your deployment files. If your model or other elements can be imported from a Python package, you can include the relevant packages in a requirements.txt file for deployment. However, if you have custom source code in local files, you will need to include those files in the deployment process.\n\n\nDeploying custom elements\nIf your VetiverModel includes custom source code, you need to include that code in your deployment files to build an API in another location. The example below shows a user-created FeatureSelector, which is part of a scikit-learn pipeline.\n\n\nmodel.py\n\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.pipeline import Pipeline\n\n# create custom data preprocessing\nclass FeatureSelector(BaseEstimator, TransformerMixin):\n    def __init__(self, columns):\n        self.columns = columns\n\n    def fit(self, X, y=None):\n        return self\n\n    def transform(self, X, y=None):\n        return X[self.columns]\n\n# create model\nmodel = Pipeline(steps=[\n    ('feature_selector', FeatureSelector(features)),\n    ('decision_tree', DecisionTreeClassifier())\n])\n\n# create deployable model object\nfrom vetiver import VetiverModel, vetiver_pin_write\n\nv = VetiverModel(model, \"selected_decision_tree\", protoype_data = X)\n\n# pin model to some location, eg, Posit Connect\nimport pins\n\nboard = pins.board_connect(allow_pickle_read=True)\nvetiver_pin_write(board, v)\n\n\nDockerPosit Connect\n\n\nTo generate files needed to start a Docker container, you can use the command vetiver.prepare_docker.\nvetiver.prepare_docker(board, \"selected_decision_tree\")\nWhen you run this line, 3 files are generated: a Dockerfile, an app.py file, and a vetiver_requirements.txt. In the app.py file, you’ll need to add an import statement that is formatted from {name of file, excluding .py, that has custom element} import {name of custom element}.\n\n\napp.py\n\nfrom vetiver import VetiverModel\nimport vetiver\nimport pins\nfrom model import FeatureSelector # add this line to import your custom feature engineering\n\n\nb = pins.board_connect(allow_pickle_read=True)\nv = VetiverModel.from_pin(b, 'selected_decision_tree')\n\nvetiver_api = vetiver.VetiverAPI(v)\napi = vetiver_api.app\n\nAdd a line to your Dockerfile to copy your source file(s) into your Docker container. The format will be COPY path/to/your/filename.py /vetiver/app/filename.py, where the destination is always in the /vetiver/app/ directory.\n\n\nDockerfile\n\n# # Generated by the vetiver package; edit with care\n# start with python base image\nFROM python:3.10\n\n# create directory in container for vetiver files\nWORKDIR /vetiver\n\n# copy  and install requirements\nCOPY vetiver_requirements.txt /vetiver/requirements.txt\n\n#\nRUN pip install --no-cache-dir --upgrade -r /vetiver/requirements.txt\n\n# copy app file\nCOPY app.py /vetiver/app/app.py\n\n# ADD THIS LINE to copy model source code\nCOPY model.py /vetiver/app/model.py\n\n# expose port\nEXPOSE 8080\n\n# run vetiver API\nCMD [\"uvicorn\", \"app.app:api\", \"--host\", \"0.0.0.0\", \"--port\", \"8080\"]\n\n\n\nTo deploy custom code to Posit Connect, you’ll first start with the command vetiver.write_app.\nvetiver.write_app(board, 'selected_decision_tree')\nThis will generate an app.py file, where you’ll need to add an import statement that is formatted from {name of file, excluding .py, that has custom element} import {name of custom element}.\n\n\n=\"app.py\"\n\nfrom vetiver import VetiverModel\nimport vetiver\nimport pins\nfrom model import FeatureSelector # add this line to import your custom feature engineering\n\n\nb = pins.board_connect(allow_pickle_read=True)\nv = VetiverModel.from_pin(b, 'selected_decision_tree')\n\nvetiver_api = vetiver.VetiverAPI(v)\napi = vetiver_api.app\n\nAfter editing the app.py file, you can deploy it to Posit Connect using the rsconnect package. Use the rsconnect.api.actions.deploy_python_fastapi() function to deploy the API, specifying the Connect server URL, API key, directory containing the app.py and model.py files, and the entry point of the API.\nfrom rsconnect.api.actions import deploy_python_fastapi\nimport rsconnect\n\nurl = \"example.connect.com\" # your Posit Connect server url\napi_key = os.environ(CONNECT_API_KEY) # your Posit Connect API key\n\nconnect_server = rsconnect.api.RSConnectServer(\n    url = url,\n    api_key = api_key\n)\n\nrsconnect.actions.deploy_python_fastapi(\n        connect_server = connect_server,\n        directory = \"./\", # path to the directory containing the app.py and model.py files\n        entry_point = \"app:api\" # the API is the app.py file, in a variable named api\n    )\n\n\n\nPlease note that the above steps are a general guide, and you may need to adapt them to your specific use case and deployment environment. If you have any questions, please consider opening an issue."
  },
  {
    "objectID": "reference/plot_metrics.html",
    "href": "reference/plot_metrics.html",
    "title": "plot_metrics",
    "section": "",
    "text": "plot_metrics(df_metrics, date, estimate, metric, n, **kw)\nPlot metrics over a given time period",
    "crumbs": [
      "Reference",
      "Monitor",
      "plot_metrics"
    ]
  },
  {
    "objectID": "reference/plot_metrics.html#parameters",
    "href": "reference/plot_metrics.html#parameters",
    "title": "plot_metrics",
    "section": "Parameters",
    "text": "Parameters\n\ndf_metrics : DataFrame\n\nPandas dataframe of metrics over time, such as created by compute_metrics()\n\ndate :  = 'index'\n\nName of column in df_metrics containing dates\n\nestimate :  = 'estimate'\n\nName of column in df_metrics containing metric output\n\nmetric :  = 'metric'\n\nName of column in df_metrics containing metric name\n\nn :  = 'n'\n\nName of column in df_metrics containing number of observations",
    "crumbs": [
      "Reference",
      "Monitor",
      "plot_metrics"
    ]
  },
  {
    "objectID": "reference/plot_metrics.html#returns",
    "href": "reference/plot_metrics.html#returns",
    "title": "plot_metrics",
    "section": "Returns",
    "text": "Returns\n\n : plotly.express.line\n\nA plotly line plot is returned with metrics over time",
    "crumbs": [
      "Reference",
      "Monitor",
      "plot_metrics"
    ]
  },
  {
    "objectID": "reference/plot_metrics.html#examples",
    "href": "reference/plot_metrics.html#examples",
    "title": "plot_metrics",
    "section": "Examples",
    "text": "Examples\nFirst, we will set up some example data.\n\nimport vetiver\nimport pandas as pd\n\n# Example data\ndf = pd.DataFrame(\n{'index': {0: pd.Timestamp('2021-01-01 00:00:00'),\n           1: pd.Timestamp('2021-01-01 00:00:00'),\n           2: pd.Timestamp('2021-01-02 00:00:00'),\n           3: pd.Timestamp('2021-01-02 00:00:00')},\n 'n': {0: 1, 1: 1, 2: 1, 3: 1},\n 'metric': {0: 'mean_squared_error',\n            1: 'mean_absolute_error',\n            2: 'mean_squared_error',\n            3: 'mean_absolute_error'},\n 'estimate': {0: 4.0, 1: 2.0, 2: 1.0, 3: 1.0}}\n)\n\nplot = vetiver.plot_metrics(\n    df_metrics = df,\n    date = \"index\",\n    estimate = \"estimate\",\n    metric = \"metric\",\n    n = \"n\")\n\nplot.show()",
    "crumbs": [
      "Reference",
      "Monitor",
      "plot_metrics"
    ]
  },
  {
    "objectID": "reference/write_app.html",
    "href": "reference/write_app.html",
    "title": "write_app",
    "section": "",
    "text": "write_app(\n    board,\n    pin_name: str,\n    version: str = None,\n    file: str = 'app.py',\n    overwrite,\n)\nWrite VetiverAPI app to a file",
    "crumbs": [
      "Reference",
      "Deploy",
      "write_app"
    ]
  },
  {
    "objectID": "reference/write_app.html#parameters",
    "href": "reference/write_app.html#parameters",
    "title": "write_app",
    "section": "Parameters",
    "text": "Parameters\n\nboard : \n\nAPI to be written\n\npin_name : string\n\nName of pin containing VetiverModel\n\nversion : str = None\n\nPins version of VetiverModel\n\nfile : str = 'app.py'\n\nName of file",
    "crumbs": [
      "Reference",
      "Deploy",
      "write_app"
    ]
  },
  {
    "objectID": "reference/write_app.html#examples",
    "href": "reference/write_app.html#examples",
    "title": "write_app",
    "section": "Examples",
    "text": "Examples\n\nimport vetiver\nimport tempfile\nimport pins\n\ntmp = tempfile.TemporaryDirectory()\nboard = pins.board_temp(allow_pickle_read=True)\n\nX, y = vetiver.get_mock_data()\nmodel = vetiver.get_mock_model().fit(X, y)\nv = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\n\nvetiver.vetiver_pin_write(board, v)\nvetiver.write_app(board,\n    \"my_model\",\n    file = tmp.name + \"/app.py\")\n\nModel Cards provide a framework for transparent, responsible reporting. \n Use the vetiver `.qmd` Quarto template as a place to start, \n with vetiver.model_card()\nWriting pin:\nName: 'my_model'\nVersion: 20241210T193530Z-78391",
    "crumbs": [
      "Reference",
      "Deploy",
      "write_app"
    ]
  },
  {
    "objectID": "reference/prepare_docker.html",
    "href": "reference/prepare_docker.html",
    "title": "prepare_docker",
    "section": "",
    "text": "prepare_docker(\n    board,\n    pin_name: str,\n    path: str = './',\n    version,\n    rspm_env: bool = False,\n    host: str = '0.0.0.0',\n    port: str = '8080',\n)\nGenerate files needed for Docker\nDeploying a vetiver model via Docker requires several files. This function will generate a Dockerfile, app.py file, and a requirements.txt to be usedto build and run a Docker container.\n\n\n\nboard : \n\nPin board for model\n\npin_name : str\n\nName of pin\n\npath : Path | str = './'\n\nPath to output\n\nversion : str = None\n\nPin version to be used. If none is supplied, the most recent pin will be selected.\n\nrspm_env : bool = False\n\nWhether or not Posit Package Manager should be used\n\nhost : str = '0.0.0.0'\n\nHost address to run VetiverAPI from Dockerfile\n\nport : str = '8080'\n\nPort to run VetiverAPI from Dockerfile\n\n\n\n\n\nimport vetiver\nimport tempfile\nimport pins\n\ntmp = tempfile.TemporaryDirectory()\nboard = pins.board_temp(allow_pickle_read=True)\n\nX, y = vetiver.get_mock_data()\nmodel = vetiver.get_mock_model().fit(X, y)\nv = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\n\nvetiver.vetiver_pin_write(board, v)\nvetiver.prepare_docker(board = board, pin_name = \"my_model\", path = tmp.name)\n\n\n\nThis function uses vetiver.get_board_pkgs(board) for generating requirements. For more complex use cases, call write_docker(), load_pkgs(), and write_app() individually.",
    "crumbs": [
      "Reference",
      "Deploy",
      "prepare_docker"
    ]
  },
  {
    "objectID": "reference/prepare_docker.html#parameters",
    "href": "reference/prepare_docker.html#parameters",
    "title": "prepare_docker",
    "section": "",
    "text": "board : \n\nPin board for model\n\npin_name : str\n\nName of pin\n\npath : Path | str = './'\n\nPath to output\n\nversion : str = None\n\nPin version to be used. If none is supplied, the most recent pin will be selected.\n\nrspm_env : bool = False\n\nWhether or not Posit Package Manager should be used\n\nhost : str = '0.0.0.0'\n\nHost address to run VetiverAPI from Dockerfile\n\nport : str = '8080'\n\nPort to run VetiverAPI from Dockerfile",
    "crumbs": [
      "Reference",
      "Deploy",
      "prepare_docker"
    ]
  },
  {
    "objectID": "reference/prepare_docker.html#examples",
    "href": "reference/prepare_docker.html#examples",
    "title": "prepare_docker",
    "section": "",
    "text": "import vetiver\nimport tempfile\nimport pins\n\ntmp = tempfile.TemporaryDirectory()\nboard = pins.board_temp(allow_pickle_read=True)\n\nX, y = vetiver.get_mock_data()\nmodel = vetiver.get_mock_model().fit(X, y)\nv = vetiver.VetiverModel(model, \"my_model\", prototype_data = X)\n\nvetiver.vetiver_pin_write(board, v)\nvetiver.prepare_docker(board = board, pin_name = \"my_model\", path = tmp.name)",
    "crumbs": [
      "Reference",
      "Deploy",
      "prepare_docker"
    ]
  },
  {
    "objectID": "reference/prepare_docker.html#notes",
    "href": "reference/prepare_docker.html#notes",
    "title": "prepare_docker",
    "section": "",
    "text": "This function uses vetiver.get_board_pkgs(board) for generating requirements. For more complex use cases, call write_docker(), load_pkgs(), and write_app() individually.",
    "crumbs": [
      "Reference",
      "Deploy",
      "prepare_docker"
    ]
  },
  {
    "objectID": "reference/XGBoostHandler.html",
    "href": "reference/XGBoostHandler.html",
    "title": "XGBoostHandler",
    "section": "",
    "text": "XGBoostHandler(self, model, prototype_data)\nHandler class for creating VetiverModels with xgboost.\n\n\n\nmodel : xgboost.Booster\n\na trained and fit xgboost model\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nXGBoostHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data\n\n\n\n\n\n\n : prediction\n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "XGBoostHandler"
    ]
  },
  {
    "objectID": "reference/XGBoostHandler.html#parameters",
    "href": "reference/XGBoostHandler.html#parameters",
    "title": "XGBoostHandler",
    "section": "",
    "text": "model : xgboost.Booster\n\na trained and fit xgboost model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "XGBoostHandler"
    ]
  },
  {
    "objectID": "reference/XGBoostHandler.html#methods",
    "href": "reference/XGBoostHandler.html#methods",
    "title": "XGBoostHandler",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nXGBoostHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data\n\n\n\n\n\n\n : prediction\n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "XGBoostHandler"
    ]
  },
  {
    "objectID": "reference/pin_metrics.html",
    "href": "reference/pin_metrics.html",
    "title": "pin_metrics",
    "section": "",
    "text": "pin_metrics(\n    board,\n    df_metrics: pd.DataFrame,\n    metrics_pin_name: str,\n    pin_type: str | None = None,\n    index_name: str = 'index',\n    overwrite: bool = False,\n)\nUpdate an existing pin storing model metrics over time\n\n\n\nboard : \n\nPins board\n\ndf_metrics : pd.DataFrame\n\nDataframe of metrics over time, such as created by vetiver_compute_metrics()\n\nmetrics_pin_name : str\n\nPin name for where the metrics are stored\n\nindex_name : str = 'index'\n\nThe column in df_metrics containing the aggregated dates or datetimes. Note that this defaults to a column named “index”.\n\noverwrite : bool = False\n\nIf True, overwrite any metrics for dates that exist both in the existing pin and new metrics with the new values. If False, error when the new metrics contain overlapping dates with the existing pin.\n\n\n\n\n\nimport pins\nimport vetiver\ndf = pd.DataFrame(\n{'index': {0: pd.Timestamp('2021-01-01 00:00:00'),\n           1: pd.Timestamp('2021-01-01 00:00:00'),\n           2: pd.Timestamp('2021-01-02 00:00:00'),\n           3: pd.Timestamp('2021-01-02 00:00:00')},\n 'n': {0: 1, 1: 1, 2: 1, 3: 1},\n 'metric': {0: 'mean_squared_error',\n            1: 'mean_absolute_error',\n            2: 'mean_squared_error',\n            3: 'mean_absolute_error'},\n 'estimate': {0: 4.0, 1: 2.0, 2: 1.0, 3: 1.0}}\n)\nboard = pins.board_temp()\nboard.pin_write(df, \"metrics\", type = \"csv\")\n\ndf = pd.DataFrame(\n{'index': {0: pd.Timestamp('2021-01-02 00:00:00'),\n           1: pd.Timestamp('2021-01-02 00:00:00'),\n           2: pd.Timestamp('2021-01-03 00:00:00'),\n           3: pd.Timestamp('2021-01-03 00:00:00')},\n 'n': {0: 1, 1: 1, 2: 1, 3: 1},\n 'metric': {0: 'mean_squared_error',\n            1: 'mean_absolute_error',\n            2: 'mean_squared_error',\n            3: 'mean_absolute_error'},\n 'estimate': {0: 4.0, 1: 6.0, 2: 2.0, 3: 1.0}}\n)\nvetiver.pin_metrics(\n   board=board,\n   df_metrics=df2,\n   metrics_pin_name=\"metrics\",\n   index_name=\"index\",\n   overwrite=True)",
    "crumbs": [
      "Reference",
      "Monitor",
      "pin_metrics"
    ]
  },
  {
    "objectID": "reference/pin_metrics.html#parameters",
    "href": "reference/pin_metrics.html#parameters",
    "title": "pin_metrics",
    "section": "",
    "text": "board : \n\nPins board\n\ndf_metrics : pd.DataFrame\n\nDataframe of metrics over time, such as created by vetiver_compute_metrics()\n\nmetrics_pin_name : str\n\nPin name for where the metrics are stored\n\nindex_name : str = 'index'\n\nThe column in df_metrics containing the aggregated dates or datetimes. Note that this defaults to a column named “index”.\n\noverwrite : bool = False\n\nIf True, overwrite any metrics for dates that exist both in the existing pin and new metrics with the new values. If False, error when the new metrics contain overlapping dates with the existing pin.",
    "crumbs": [
      "Reference",
      "Monitor",
      "pin_metrics"
    ]
  },
  {
    "objectID": "reference/pin_metrics.html#examples",
    "href": "reference/pin_metrics.html#examples",
    "title": "pin_metrics",
    "section": "",
    "text": "import pins\nimport vetiver\ndf = pd.DataFrame(\n{'index': {0: pd.Timestamp('2021-01-01 00:00:00'),\n           1: pd.Timestamp('2021-01-01 00:00:00'),\n           2: pd.Timestamp('2021-01-02 00:00:00'),\n           3: pd.Timestamp('2021-01-02 00:00:00')},\n 'n': {0: 1, 1: 1, 2: 1, 3: 1},\n 'metric': {0: 'mean_squared_error',\n            1: 'mean_absolute_error',\n            2: 'mean_squared_error',\n            3: 'mean_absolute_error'},\n 'estimate': {0: 4.0, 1: 2.0, 2: 1.0, 3: 1.0}}\n)\nboard = pins.board_temp()\nboard.pin_write(df, \"metrics\", type = \"csv\")\n\ndf = pd.DataFrame(\n{'index': {0: pd.Timestamp('2021-01-02 00:00:00'),\n           1: pd.Timestamp('2021-01-02 00:00:00'),\n           2: pd.Timestamp('2021-01-03 00:00:00'),\n           3: pd.Timestamp('2021-01-03 00:00:00')},\n 'n': {0: 1, 1: 1, 2: 1, 3: 1},\n 'metric': {0: 'mean_squared_error',\n            1: 'mean_absolute_error',\n            2: 'mean_squared_error',\n            3: 'mean_absolute_error'},\n 'estimate': {0: 4.0, 1: 6.0, 2: 2.0, 3: 1.0}}\n)\nvetiver.pin_metrics(\n   board=board,\n   df_metrics=df2,\n   metrics_pin_name=\"metrics\",\n   index_name=\"index\",\n   overwrite=True)",
    "crumbs": [
      "Reference",
      "Monitor",
      "pin_metrics"
    ]
  },
  {
    "objectID": "reference/TorchHandler.html",
    "href": "reference/TorchHandler.html",
    "title": "TorchHandler",
    "section": "",
    "text": "TorchHandler(self, model, prototype_data)\nHandler class for creating VetiverModels with torch.\n\n\n\nmodel : nn.Module\n\na trained torch model\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nTorchHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data\n\n\n\n\n\n\n : prediction\n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "TorchHandler"
    ]
  },
  {
    "objectID": "reference/TorchHandler.html#parameters",
    "href": "reference/TorchHandler.html#parameters",
    "title": "TorchHandler",
    "section": "",
    "text": "model : nn.Module\n\na trained torch model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "TorchHandler"
    ]
  },
  {
    "objectID": "reference/TorchHandler.html#methods",
    "href": "reference/TorchHandler.html#methods",
    "title": "TorchHandler",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhandler_predict\nGenerates method for /predict endpoint in VetiverAPI\n\n\n\n\n\nTorchHandler.handler_predict(input_data, check_prototype)\nGenerates method for /predict endpoint in VetiverAPI\nThe handler_predict function executes at each API call. Use this function for calling predict() and any other tasks that must be executed at each API call.\n\n\n\ninput_data : \n\nTest data\n\n\n\n\n\n\n : prediction\n\nPrediction from model",
    "crumbs": [
      "Reference",
      "Model Handlers",
      "TorchHandler"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.vetiver_post.html",
    "href": "reference/VetiverAPI.vetiver_post.html",
    "title": "VetiverAPI.vetiver_post",
    "section": "",
    "text": "VetiverAPI.vetiver_post(endpoint_fx: Callable, endpoint_name: str = None, **kw)\nCreate new POST endpoint that is aware of model input data",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI.vetiver_post"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.vetiver_post.html#parameters",
    "href": "reference/VetiverAPI.vetiver_post.html#parameters",
    "title": "VetiverAPI.vetiver_post",
    "section": "Parameters",
    "text": "Parameters\n\nendpoint_fx : typing.Callable\n\nCustom function to be run at endpoint\n\nendpoint_name : str = None\n\nName of endpoint",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI.vetiver_post"
    ]
  },
  {
    "objectID": "reference/VetiverAPI.vetiver_post.html#examples",
    "href": "reference/VetiverAPI.vetiver_post.html#examples",
    "title": "VetiverAPI.vetiver_post",
    "section": "Examples",
    "text": "Examples\n\nfrom vetiver import mock, VetiverModel, VetiverAPI\nX, y = mock.get_mock_data()\nmodel = mock.get_mock_model().fit(X, y)\n\nv = VetiverModel(model = model, model_name = \"model\", prototype_data = X)\nv_api = VetiverAPI(model = v, check_prototype = True)\n\ndef sum_values(x):\n    return x.sum()\nv_api.vetiver_post(sum_values, \"sums\")",
    "crumbs": [
      "Reference",
      "Deploy",
      "VetiverAPI.vetiver_post"
    ]
  },
  {
    "objectID": "reference/compute_metrics.html",
    "href": "reference/compute_metrics.html",
    "title": "compute_metrics",
    "section": "",
    "text": "compute_metrics(\n    data: pd.DataFrame,\n    date_var: str,\n    period: timedelta,\n    metric_set: list,\n    truth: str,\n    estimate: str,\n    **kw,\n)\nCompute metrics for given time period",
    "crumbs": [
      "Reference",
      "Monitor",
      "compute_metrics"
    ]
  },
  {
    "objectID": "reference/compute_metrics.html#parameters",
    "href": "reference/compute_metrics.html#parameters",
    "title": "compute_metrics",
    "section": "Parameters",
    "text": "Parameters\n\ndata : DataFrame\n\nPandas dataframe\n\ndate_var : str\n\nColumn in data containing dates\n\nperiod : timedelta\n\nDefining period to group by\n\nmetric_set : list\n\nList of metrics to compute, that have the parameters y_true and y_pred\n\ntruth : str\n\nColumn name for true results\n\nestimate : str\n\nColumn name for predicted results",
    "crumbs": [
      "Reference",
      "Monitor",
      "compute_metrics"
    ]
  },
  {
    "objectID": "reference/compute_metrics.html#examples",
    "href": "reference/compute_metrics.html#examples",
    "title": "compute_metrics",
    "section": "Examples",
    "text": "Examples\n\nimport pandas as pd\nfrom vetiver import compute_metrics\nfrom datetime import timedelta\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\ndf = pd.DataFrame(\n  {\n       \"index\": [\"2021-01-01\", \"2021-01-02\", \"2021-01-03\"],\n       \"truth\": [200, 201, 199],\n       \"pred\": [198, 200, 199],\n  }\n)\ntd = timedelta(days = 1)\nmetric_set = [mean_squared_error, mean_absolute_error]\nmetrics = compute_metrics(df, \"index\", td, metric_set, \"truth\", \"pred\")\nmetrics\n\n\n\n\n\n\n\n\nindex\nn\nmetric\nestimate\n\n\n\n\n0\n2021-01-01\n1\nmean_squared_error\n4.0\n\n\n1\n2021-01-01\n1\nmean_absolute_error\n2.0\n\n\n2\n2021-01-02\n1\nmean_squared_error\n1.0\n\n\n3\n2021-01-02\n1\nmean_absolute_error\n1.0",
    "crumbs": [
      "Reference",
      "Monitor",
      "compute_metrics"
    ]
  },
  {
    "objectID": "reference/predict.html",
    "href": "reference/predict.html",
    "title": "predict",
    "section": "",
    "text": "predict(endpoint, data: Union[dict, pd.DataFrame, pd.Series], **kw)\nMake a prediction from model endpoint\n\n\n\nendpoint : \n\nURI path to endpoint\n\ndata : Union[dict, pd.DataFrame, pd.Series]\n\nNew data for making predictions, such as a data frame.\n\n\n\n\n\n\n : dict\n\nEndpoint_name and list of endpoint_fx output\n\n\n\n\n\nfrom vetiver import vetiver_endpoint, mock, predict\nX, y = mock.get_mock_data()\nendpoint = vetiver_endpoint(url='http://127.0.0.1:8000/predict')\npredict(endpoint, X)\n\n\n\nTo authorize a request to Posit Connect, pass in a dictionary of headers that includes your API key. For example:\nh = { 'Authorization': f'Key {api_key}' }\nresponse = predict(data = data, endpoint = endpoint, headers=h)",
    "crumbs": [
      "Reference",
      "Deploy",
      "predict"
    ]
  },
  {
    "objectID": "reference/predict.html#parameters",
    "href": "reference/predict.html#parameters",
    "title": "predict",
    "section": "",
    "text": "endpoint : \n\nURI path to endpoint\n\ndata : Union[dict, pd.DataFrame, pd.Series]\n\nNew data for making predictions, such as a data frame.",
    "crumbs": [
      "Reference",
      "Deploy",
      "predict"
    ]
  },
  {
    "objectID": "reference/predict.html#returns",
    "href": "reference/predict.html#returns",
    "title": "predict",
    "section": "",
    "text": ": dict\n\nEndpoint_name and list of endpoint_fx output",
    "crumbs": [
      "Reference",
      "Deploy",
      "predict"
    ]
  },
  {
    "objectID": "reference/predict.html#examples",
    "href": "reference/predict.html#examples",
    "title": "predict",
    "section": "",
    "text": "from vetiver import vetiver_endpoint, mock, predict\nX, y = mock.get_mock_data()\nendpoint = vetiver_endpoint(url='http://127.0.0.1:8000/predict')\npredict(endpoint, X)",
    "crumbs": [
      "Reference",
      "Deploy",
      "predict"
    ]
  },
  {
    "objectID": "reference/predict.html#notes",
    "href": "reference/predict.html#notes",
    "title": "predict",
    "section": "",
    "text": "To authorize a request to Posit Connect, pass in a dictionary of headers that includes your API key. For example:\nh = { 'Authorization': f'Key {api_key}' }\nresponse = predict(data = data, endpoint = endpoint, headers=h)",
    "crumbs": [
      "Reference",
      "Deploy",
      "predict"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Vetiver:v0.2.5.post5+ga466e36",
    "section": "",
    "text": "VetiverModel\nCreate VetiverModel class for serving.\n\n\nvetiver_pin_write\nPin a trained VetiverModel along with other model metadata.\n\n\nvetiver_create_prototype\nCreate zero row structure to save data types\n\n\ntemplates.model_card\nCreate a model card for documentation\n\n\n\n\n\n\n\n\n\nVetiverAPI\nCreate model aware API\n\n\nVetiverAPI.run\nStart API\n\n\nVetiverAPI.vetiver_post\nCreate new POST endpoint that is aware of model input data\n\n\nvetiver_endpoint\nWrap url where VetiverModel will be deployed\n\n\npredict\nMake a prediction from model endpoint\n\n\nwrite_app\nWrite VetiverAPI app to a file\n\n\nprepare_docker\nGenerate files needed for Docker\n\n\nwrite_docker.write_docker\nWrites a Dockerfile to run VetiverAPI in a container\n\n\ndeploy_rsconnect\nDeploy to Posit Connect\n\n\n\n\n\n\n\n\n\ncompute_metrics\nCompute metrics for given time period\n\n\npin_metrics\nUpdate an existing pin storing model metrics over time\n\n\nplot_metrics\nPlot metrics over a given time period\n\n\ntemplates.monitoring_dashboard\nGenerate a monitoring dashboard template\n\n\n\n\n\n\n\n\n\nBaseHandler\nBase handler class for creating VetiverModel of different types of model.\n\n\nSKLearnHandler\nHandler class for creating VetiverModels with sklearn.\n\n\nTorchHandler\nHandler class for creating VetiverModels with torch.\n\n\nStatsmodelsHandler\nHandler class for creating VetiverModels with statsmodels.\n\n\nXGBoostHandler\nHandler class for creating VetiverModels with xgboost.\n\n\nSpacyHandler\nHandler class for creating VetiverModels with spacy.",
    "crumbs": [
      "Reference",
      "Vetiver:v{{< env VERSION >}}"
    ]
  },
  {
    "objectID": "reference/index.html#version",
    "href": "reference/index.html#version",
    "title": "Vetiver:v0.2.5.post5+ga466e36",
    "section": "",
    "text": "VetiverModel\nCreate VetiverModel class for serving.\n\n\nvetiver_pin_write\nPin a trained VetiverModel along with other model metadata.\n\n\nvetiver_create_prototype\nCreate zero row structure to save data types\n\n\ntemplates.model_card\nCreate a model card for documentation",
    "crumbs": [
      "Reference",
      "Vetiver:v{{< env VERSION >}}"
    ]
  },
  {
    "objectID": "reference/index.html#deploy",
    "href": "reference/index.html#deploy",
    "title": "Vetiver:v0.2.5.post5+ga466e36",
    "section": "",
    "text": "VetiverAPI\nCreate model aware API\n\n\nVetiverAPI.run\nStart API\n\n\nVetiverAPI.vetiver_post\nCreate new POST endpoint that is aware of model input data\n\n\nvetiver_endpoint\nWrap url where VetiverModel will be deployed\n\n\npredict\nMake a prediction from model endpoint\n\n\nwrite_app\nWrite VetiverAPI app to a file\n\n\nprepare_docker\nGenerate files needed for Docker\n\n\nwrite_docker.write_docker\nWrites a Dockerfile to run VetiverAPI in a container\n\n\ndeploy_rsconnect\nDeploy to Posit Connect",
    "crumbs": [
      "Reference",
      "Vetiver:v{{< env VERSION >}}"
    ]
  },
  {
    "objectID": "reference/index.html#monitor",
    "href": "reference/index.html#monitor",
    "title": "Vetiver:v0.2.5.post5+ga466e36",
    "section": "",
    "text": "compute_metrics\nCompute metrics for given time period\n\n\npin_metrics\nUpdate an existing pin storing model metrics over time\n\n\nplot_metrics\nPlot metrics over a given time period\n\n\ntemplates.monitoring_dashboard\nGenerate a monitoring dashboard template",
    "crumbs": [
      "Reference",
      "Vetiver:v{{< env VERSION >}}"
    ]
  },
  {
    "objectID": "reference/index.html#model-handlers",
    "href": "reference/index.html#model-handlers",
    "title": "Vetiver:v0.2.5.post5+ga466e36",
    "section": "",
    "text": "BaseHandler\nBase handler class for creating VetiverModel of different types of model.\n\n\nSKLearnHandler\nHandler class for creating VetiverModels with sklearn.\n\n\nTorchHandler\nHandler class for creating VetiverModels with torch.\n\n\nStatsmodelsHandler\nHandler class for creating VetiverModels with statsmodels.\n\n\nXGBoostHandler\nHandler class for creating VetiverModels with xgboost.\n\n\nSpacyHandler\nHandler class for creating VetiverModels with spacy.",
    "crumbs": [
      "Reference",
      "Vetiver:v{{< env VERSION >}}"
    ]
  },
  {
    "objectID": "reference/VetiverModel.html",
    "href": "reference/VetiverModel.html",
    "title": "VetiverModel",
    "section": "",
    "text": "VetiverModel(\n    self,\n    model,\n    model_name: str,\n    prototype_data,\n    versioned,\n    description: str = None,\n    metadata: dict = None,\n    **kwargs,\n)\nCreate VetiverModel class for serving.",
    "crumbs": [
      "Reference",
      "Version",
      "VetiverModel"
    ]
  },
  {
    "objectID": "reference/VetiverModel.html#parameters",
    "href": "reference/VetiverModel.html#parameters",
    "title": "VetiverModel",
    "section": "Parameters",
    "text": "Parameters\n\nmodel : \n\nA trained model, such as an sklearn or torch model\n\nmodel_name : string\n\nModel name or ID\n\nprototype_data : (pd.DataFrame, np.array) = None\n\nSample of data model should expect when it is being served\n\nversioned :  = None\n\nShould the model be versioned when created?\n\ndescription : str = None\n\nA detailed description of the model. If omitted, a brief description will be generated.\n\nmetadata : dict = None\n\nOther details to be saved and accessed for serving\n\nkwargs :  = {}\n\nDeprecated parameters.",
    "crumbs": [
      "Reference",
      "Version",
      "VetiverModel"
    ]
  },
  {
    "objectID": "reference/VetiverModel.html#attributes",
    "href": "reference/VetiverModel.html#attributes",
    "title": "VetiverModel",
    "section": "Attributes",
    "text": "Attributes\n\nprototype : vetiver.Prototype\n\nData prototype\n\nhandler_predict : Callable\n\nMethod to make predictions from a trained model",
    "crumbs": [
      "Reference",
      "Version",
      "VetiverModel"
    ]
  },
  {
    "objectID": "reference/VetiverModel.html#notes",
    "href": "reference/VetiverModel.html#notes",
    "title": "VetiverModel",
    "section": "Notes",
    "text": "Notes\nVetiverModel can also take an initialized custom VetiverHandler as a model, for advanced use cases or non-supported model types. Parameter ptype_data was changed to prototype_data. Handling of ptype_data will be removed in a future version.",
    "crumbs": [
      "Reference",
      "Version",
      "VetiverModel"
    ]
  },
  {
    "objectID": "reference/VetiverModel.html#examples",
    "href": "reference/VetiverModel.html#examples",
    "title": "VetiverModel",
    "section": "Examples",
    "text": "Examples\n\nfrom vetiver import mock, VetiverModel\nX, y = mock.get_mock_data()\nmodel = mock.get_mock_model().fit(X, y)\nv = VetiverModel(model = model, model_name = \"my_model\", prototype_data = X)\nv.description\n\n'A scikit-learn DummyRegressor model'",
    "crumbs": [
      "Reference",
      "Version",
      "VetiverModel"
    ]
  },
  {
    "objectID": "reference/VetiverModel.html#methods",
    "href": "reference/VetiverModel.html#methods",
    "title": "VetiverModel",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nfrom_pin\nCreate VetiverModel from pinned model.\n\n\n\n\nfrom_pin\nVetiverModel.from_pin(board, name: str, version: str = None)\nCreate VetiverModel from pinned model.\n\nParameters\n\nboard : \n\npins board where model is located\n\nname : str\n\nModel name inside pins board\n\nversion : str = None\n\nWhat model version should be loaded",
    "crumbs": [
      "Reference",
      "Version",
      "VetiverModel"
    ]
  },
  {
    "objectID": "reference/vetiver_endpoint.html",
    "href": "reference/vetiver_endpoint.html",
    "title": "vetiver_endpoint",
    "section": "",
    "text": "vetiver_endpoint(url: str = 'http://127.0.0.1:8000/predict')\nWrap url where VetiverModel will be deployed",
    "crumbs": [
      "Reference",
      "Deploy",
      "vetiver_endpoint"
    ]
  },
  {
    "objectID": "reference/vetiver_endpoint.html#parameters",
    "href": "reference/vetiver_endpoint.html#parameters",
    "title": "vetiver_endpoint",
    "section": "Parameters",
    "text": "Parameters\n\nurl : str = 'http://127.0.0.1:8000/predict'\n\nURI path to endpoint",
    "crumbs": [
      "Reference",
      "Deploy",
      "vetiver_endpoint"
    ]
  },
  {
    "objectID": "reference/vetiver_endpoint.html#returns",
    "href": "reference/vetiver_endpoint.html#returns",
    "title": "vetiver_endpoint",
    "section": "Returns",
    "text": "Returns\n\nurl : str\n\nURI path to endpoint",
    "crumbs": [
      "Reference",
      "Deploy",
      "vetiver_endpoint"
    ]
  },
  {
    "objectID": "reference/vetiver_endpoint.html#examples",
    "href": "reference/vetiver_endpoint.html#examples",
    "title": "vetiver_endpoint",
    "section": "Examples",
    "text": "Examples\n\nfrom vetiver import vetiver_endpoint\nendpoint = vetiver_endpoint(url='http://127.0.0.1:8000/predict')",
    "crumbs": [
      "Reference",
      "Deploy",
      "vetiver_endpoint"
    ]
  }
]